name: SetPwsh plugin Multiplatform Testing

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths-ignore:
      - README.md
      - LICENSE
  schedule:
      - cron: '0 7 * * *'

defaults:
  run:
    shell: pwsh

jobs:
  testing:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
    steps:
      - name: Detect latest Vim's release
        run: |
          $query = @{
            Authentication = "OAuth"
            Token          = ConvertTo-SecureString -String "${{ secrets.GITHUB_TOKEN }}" -AsPlainText
            Method         = "Get"
            Uri            = "https://api.github.com/repos/vim/vim-win32-installer/tags"
          }
          $tags = (Invoke-WebRequest @query).Content | ConvertFrom-Json -AsHashtable
          $release = $tags[0].name.TrimStart('v')

          Write-Host "Latest Vim release is $release"
          "RELEASE_VERSION=$release" | Out-File -Path $Env:GITHUB_ENV -Encoding OEM -Append

      - name: Checkout-install SetPwsh
        uses: actions/checkout@v5
        with:
          path: workplace/vim/runtime/pack/SetPwsh

      - name: Install WSL2
        if: contains(matrix.os, 'windows')
        uses: Vampire/setup-wsl@v6.0.0
        with:
          additional-packages:
            curl
            openssh-client
            dos2unix
          distribution: Ubuntu-24.04
          set-as-default: 'true'
          use-cache: 'true'
          wsl-version: 2

      - name: Install Docker inside WSL2
        if: contains(matrix.os, 'windows')
        shell: wsl-bash {0}
        run: |
          curl -fsSL https://get.docker.com -o install-docker.sh
          sudo sh install-docker.sh

      - name: Set up a SSH server in Docker
        if: contains(matrix.os, 'windows') || contains(matrix.os, 'ubuntu')
        run: |
          # Set up keys
          pushd workplace/vim/runtime/pack/SetPwsh/.github/workflows
          mkdir sshkeys

          @"
          ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGazb0M5H6YIIyiZBbNkbfjca6QZszzvx/9G0/SB6Ee5 migue@Laptop-Barro
          "@ | Out-File -FilePath sshkeys/sshkey.pub -Encoding ASCII

          @"
          ${{ secrets.SSHKEY }}
          "@ | Out-File -FilePath sshkeys/sshkey -Encoding ASCII

          # Set file permissions
          if ($IsWindows)
          {
            # Disable inheritance
            $acl = Get-Acl -PSPath ./sshkeys/sshkey
            $acl.SetAccessRuleProtection($true, $true)
            $acl | Set-Acl -PSPath ./sshkeys/sshkey

            # Modify rules
            $acl = Get-Acl -PSPath ./sshkeys/sshkey
            $rule = $acl.Access | ? IdentityReference -eq "BUILTIN\Users"
            $acl.RemoveAccessRuleAll($rule)
            $acl | Set-Acl -PSPath ./sshkeys/sshkey

            # Copy the key to WSL2 to allow wsl ssh client usage
            wsl mkdir '$HOME/sshkeys'
            wsl cp sshkeys/sshkey '$HOME/sshkeys/sshkey'
          }
          else
          {
            chmod 600 sshkeys/sshkey
          }

          # Build docker image with SSH server
          $docker = $IsWindows ? { wsl -- docker $args 2>$null} : "docker"
          $base_image = "alpine:latest"
          $sshport = 42

          & $docker build `
            --build-arg sshport=$sshport `
            --build-arg base_image=$base_image `
            --build-arg pubkey=sshkeys/sshkey.pub -t alpine:test .

          # Run SSH server in background
          & $docker run --rm -d -p "${sshport}:${sshport}" --name sshtest alpine:test

          # Avoid fingerprint prompt
          mkdir ~/.ssh
          (& $docker exec sshtest ssh-keyscan -p $sshport -H localhost) |
            Out-File -Path ~/.ssh/known_hosts -Encoding OEM -Append

          # Set up ssh agent and add private key
          if ($IsWindows)
          {
            if ((Get-Service ssh-agent).StartType -eq "Disabled")
            {
              Set-Service -Name ssh-agent -StartupType Manual
            }
            Start-Service ssh-agent
          }
          else
          {
            (ssh-agent -s | Select-String "^(?<name>.*)=(?<value>[^;]*);").Matches |
              ForEach-Object {
                # Extract environment variables
                $name = ($_.Groups | ? Name -eq "name")
                $value = ($_.Groups | ? Name -eq "value")
                # Use locally
                Invoke-Expression "`$Env:$name=`"$value`""
                # Persist for next steps
                "$name=$value" | Out-File -Path $Env:GITHUB_ENV -Encoding OEM -Append
              }
          }
          ssh-add ./sshkeys/sshkey

          # Populate environment variable for next steps
          "SETPWSH_SSHCONFIG=sshuser@localhost:$sshport" |
            Out-File -Path $Env:GITHUB_ENV -Encoding OEM -Append

      - name: Set up WSL2
        if: contains(matrix.os, 'windows')
        shell: wsl-bash {0}
        run: |
          # Keep wsl2 running
          nohup dbus-launch true >/dev/null 2>&1 &

          # • reuse the tcp connections to avoid handshakes
          #   it only works if we keep an ssh connection open all the time
          # • set up client to use the key
          cat <<EOF > $HOME/.ssh/config
          Host *
            ControlMaster auto
            ControlPath /tmp/%r@%h:%p
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null

          Host localhost
              Hostname 127.0.0.1
              User sshuser
              IdentityFile $HOME/sshkeys/sshkey
          EOF

          # set up right key permissions
          dos2unix $HOME/sshkeys/sshkey
          sudo chmod 600 $HOME/sshkeys/sshkey

      - name: Install Vim
        timeout-minutes: 5
        run: |
          $basedir = Get-Location

          pushd workplace

          # Download Vim sources
          Invoke-WebRequest -Uri https://github.com/vim/vim/archive/refs/tags/v$Env:RELEASE_VERSION.zip `
                            -OutFile vim.zip

          # Unpack Vim sources && merge SetPwsh into
          Expand-Archive -Path vim.zip -DestinationPath .
          Remove-Item vim.zip

          $vimdir = Get-Item -Path vim-*
          Move-Item -Path vim/runtime/pack/SetPwsh -Destination $vimdir/runtime/pack
          Remove-Item -Recurse -Force vim/runtime
          Move-Item -Path $vimdir/* -Destination vim
          rmdir $vimdir

          # Set helpful environment variables
          $bindir = (Get-Item -Path vim/src).FullName
          "BASEDIR=$basedir" | Out-File -Path $Env:GITHUB_ENV -Encoding OEM -Append
          "BINDIR=$bindir" | Out-File -Path $Env:GITHUB_ENV -Encoding OEM -Append
          "TESTDIR=$bindir/testdir" | Out-File -Path $Env:GITHUB_ENV -Encoding OEM -Append

          # Enter build dir
          pushd $bindir

          if ($IsWindows)
          {
            # Windows world: use precompiled binaries ... unless you need gVim ... build from sources

            # Fix Makefile to use clang-cl
            Get-Content ../runtime/pack/SetPwsh/.github/workflows/vim_mvc_clang.patch | patch -d .. -p1

            if ([version]$env:RELEASE_VERSION -lt [version]"9.1.1919")
            {
              # Fix netrw to use default ssh on windows
              Get-Content ../runtime/pack/SetPwsh/.github/workflows/netrw_unc.patch | patch -d .. -p1
            }

            # Set up development environment
            $vswhere = "${Env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
            & $vswhere -find **/Microsoft.VisualStudio.DevShell.dll | Import-Module
            Enter-VsDevShell -SetDefaultWindowTitle -InstallPath (& $vswhere -property installationPath) `
                             -StartInPath $bindir -DevCmdArguments '/arch=x64 /host_arch=x64'

            # Decide to use cl or clang-cl
            # $CC = "clang-cl"
            $CC = "cl" # MSVC compiler seems to be faster in this case

            # Build matching environment tools (x64)
            nmake -f Make_mvc.mak CC=$CC GUI=yes VIMDLL=yes CPU=AMD64 PLATFORMS=x64 `
                                  DEBUG=yes USE_MP=NO USE_MSVCRT=yes

            # For debug builds redirect to debug binaries
            if (Test-Path -Path .\vimd.exe)
            {
              New-Item -ItemType SymbolicLink -Path .\vim.exe -Target .\vimd.exe
            }

            if (Test-Path -Path .\gvimd.exe)
            {
              New-Item -ItemType SymbolicLink -Path .\gvim.exe -Target .\gvimd.exe
            }
          }
          else
          {
            # UNIX world: build from sources
            if ($IsMacOS)
            {
              Write-Warning "MacOS lacks GUI support. Check on https://github.com/macvim-dev/macvim"
            }
            else # Ubuntu runner
            {
              do
              {
                sudo apt update
                sudo apt-get install -y libx11-dev libxt-dev libxpm-dev libgtk2.0-dev libncurses-dev
              }
              while ($LASTEXITCODE -ne 0)
            }

            ./configure --prefix=/tmp/workplace --enable-gui=auto
            # Get-Content -Path ./auto/config.mk
            # Get-Content -Path ./auto/config.log
            make
          }

          # Leaving build dir
          popd

          # local
          $Env:PATH = "$bindir$([system.io.path]::PathSeparator)$Env:PATH"
          # persistent
          $bindir | Out-File -Path $Env:GITHUB_PATH -Encoding OEM -Append

      - name: Check vim binaries
        run: |
          vim --version

          if (gcm gvim -ErrorAction SilentlyContinue)
          {
            $version = New-TemporaryFile
            gvim -c "redir! > $version | version | redir END | q!"
            Get-Content -Path $version
          }

      - name: Move tests to the test folder
        run: |
          $sourcedir = Get-Item -Path $Env:BASEDIR/workplace/vim/runtime/pack/SetPwsh/start/setpwsh/tests/
          $tests = Get-ChildItem -Path $sourcedir -Filter *.vim
          $targetdir = Get-Item -Path $Env:TESTDIR
          Copy-Item -Path $tests -Destination $targetdir

          $tests | ForEach-Object {
              Write-Host "Copied test file: $_ to $targetdir"
            }

          # Login the new test
          $MakeAll = Get-Item -Path $Env:TESTDIR/Make_all.mak
          (Get-Content -Path $MakeAll | ForEach-Object {
              $_
              if ($_ -match '^NEW_TESTS =')
              {
                $tests.BaseName | ForEach-Object { " $_ \" }
              }
              elseif ($_ -match '^NEW_TESTS_RES =')
              {
                $tests.BaseName | ForEach-Object { " $_.res \" }
              }
            }
          ) | Set-Content -Path $MakeAll

      - name: Run testing
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 8
          max_attempts: 3
          shell: pwsh # nick-fields/retry disregards job's shell setting
          command: |
            if ($IsWindows)
            {
              # Keep alive ssh connection from wsl2 to avoid costly handshakes
              wsl ssh -Nfp 42 localhost
            }

            # Hint plugin location to the tests
            $Env:SETPWSH_RUNTIMEDIR = "$Env:BASEDIR/workplace/vim/runtime"

            # ScriptBlock to summarize test results
            Install-Module -Name MarkdownPS -Repository PSGallery -Force
            Import-Module MarkdownPS
            $summary = { Param([String]$binary)
                # Filter skipped tests
                (Get-Content -Path messages | % { $skip = $false} {
                  if(!$skip){ $_ }
                  $skip = $_ -match "^\s+Skipped\s*$"
                }) | Set-Content -Path messages
                # Extract test execution times
                $Tests = Select-String -Path messages -Pattern "^Executed (?<Test>.*\(\))\s+in\s+(?<Seconds>.*) seconds"
                Remove-Item messages
                $Table = $Tests.Matches | % {
                    $test = @{}
                    $_.Groups | ? Name -NotMatch '\d'  | % {
                        $test[$_.Name] = $_.Value
                    }
                    [PSCustomObject]$test
                } | Select-Object @{l="Binary"; e={$binary}}, Test, Seconds
                $Stats = $Table.Seconds | Measure-Object -Sum
                $Table += [PSCustomObject]@{
                    Binary = $binary
                    Test = "Executed " + $Stats.Count + " tests"
                    Seconds = "{0:F6}" -f $Stats.Sum
                }
                $Table | New-MDTable
            }

            # Prepare environment
            if ($IsWindows)
            {
              $vswhere = "${Env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
              & $vswhere -find **/Microsoft.VisualStudio.DevShell.dll | Import-Module
              Enter-VsDevShell -SetDefaultWindowTitle -InstallPath (& $vswhere -property installationPath) `
                               -StartInPath $Env:TESTDIR -DevCmdArguments '/arch=x64 /host_arch=x64'
              $make = "nmake"
              $makefile = "/f", "Make_mvc.mak"
              $gui = ,"VIMPROG=gvim.exe"
            }
            else
            {
              cd $Env:TESTDIR
              $make = "make"
              $makefile = @()
              $gui = ,"GUI_FLAG=-g"

              if ($IsLinux)
              {
                # Start virtual display to prevent tests from hanging
                sudo apt-get install -y xvfb
                Xvfb :42 -screen 0 1024x768x24 &
                $env:DISPLAY=":42"

                Write-Host "Running a virtual display for GUI tests DISPLAY=$env:DISPLAY"
              }
            }

            Write-Host "Executing tests: $make $makefile test_plugin_setpwsh"
            & $make @makefile test_plugin_setpwsh

            if (Test-Path -Path messages)
            {
              # Get-Content -Path messages
              if ( Select-String -Path messages -Pattern 'FAILED' )
              {
                throw "Some tests failed!!!"
              }
              & $summary -binary "vim" |
                Out-File -Path $Env:GITHUB_STEP_SUMMARY -Encoding OEM -Append
            }

            # check GUI binary availability and headless environment
            if (vim --version | Select-String -Pattern 'with GTK. GUI|GUI/console')
            {
              Write-Host "Executing tests: $make $makefile $gui test_plugin_setpwsh"
              & $make @makefile @gui test_plugin_setpwsh

              if (Test-Path -Path messages)
              {
                # Get-Content -Path messages
                if ( Select-String -Path messages -Pattern 'FAILED' )
                {
                  throw "Some tests failed!!!"
                }

                & $summary -binary "gvim" |
                  Out-File -Path $Env:GITHUB_STEP_SUMMARY -Encoding OEM -Append
              }
            }
            else
            {
              $msg = "No GUI support in this vim build. Skipping GUI tests."
              Write-Warning $msg
              "> [!WARNING]", "> $msg" |
                Out-File -Path $Env:GITHUB_STEP_SUMMARY -Encoding OEM -Append
            }

# vim: cuc sw=2 sts=2 et
